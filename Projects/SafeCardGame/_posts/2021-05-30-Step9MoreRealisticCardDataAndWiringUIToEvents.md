---
layout: post
title: SafeCardGame - Step 9 - Adding more realistic cards data and wiring up the UI to send some events
author: James Clancy
tags: fsharp dotnet
---

## Adding more realistic cards data and wiring up the UI to send some events

In order to create better test data I am going to be creating a temporary SampleCardDatabase in the Client. This SampleCardDatabase will also require several generic list methods I am putting in a CollectionManipulation module also in the client.

I am going to create a creatureCardDb which creates a list of sample creature cards and a resourceCardDb which contains a list of sample resource cards. I am ignoring the effect cards for now.

Both of these "Db"s are generated by piping lists of tuples through a constructor function and taking all the valid "Ok" results.

I implemented them like:

```
let creatureCreatureConstructor creatureId name description primaryResource resourceCost health weaknesses =
    let cardId = NonEmptyString.build creatureId |> Result.map CardId
    let cardImageUrl = ImageUrlString.build (sprintf "/images/full/%s.png" creatureId)

    match  cardId, cardImageUrl with
    |  Ok cid, Ok imgUrl ->
        Ok {
                CardId = cid
                ResourceCost =  resourceCost
                Name = name
                EnterSpecialEffects = None
                ExitSpecialEffects = None
                PrimaryResource = primaryResource
                Creature =
                      {
                        Health= health
                        Weaknesses=  weaknesses
                        Attack = List.empty
                      }
                ImageUrl = imgUrl
                Description =description
            }
    | _, _ -> Error "No"

let resourceCardConstructor resourceCardId resource =
    let cardId = NonEmptyString.build resourceCardId |> Result.map CardId
    let cardImageUrl = ImageUrlString.build (sprintf "/images/resource/%s.png" (resource.ToString()))

    match  cardId, cardImageUrl with
    |  Ok cid, Ok imgUrl ->
        Ok {
                CardId = cid
                ResourceCost =  Seq.empty |> ResourcePool
                Name = resource.ToString()
                EnterSpecialEffects = None
                ExitSpecialEffects = None
                PrimaryResource = resource
                ResourceAvailableOnFirstTurn = true
                ResourcesAdded = [ (resource, 1) ] |> ResourcePool
                ImageUrl = imgUrl
                Description = (sprintf "Add 1 %s to your available resource pool." (getSymbolForResource resource))
            }
    | _, _ -> Error "No"

let resourceCardDb =
    [
      "GrassEnergy", Resource. Grass;
      "FireEnergy", Resource.Fire;
      "WaterEnergy", Resource. Water;
      "LightningEnergy", Resource.Lightning;
      "PsychicEnergy", Resource.Psychic;
      "FightingEnergy", Resource.Fighting;
      "ColorlessEnergy", Resource.Colorless
    ] |> List.map (fun (x,y) -> resourceCardConstructor  x y)
    |> selectAllOkayResults

let creatureCardDb =
    [
      ("001", "BulbMon", "It has a bulb on it bro",Resource.Grass, [ Resource.Grass, 1; ] |> Seq.ofList |> ResourcePool, 40, [Resource.Fire] )
      ("050", "DigMon", "Mole Monster", Resource.Fighting,[ Resource.Fighting, 1; ] |> Seq.ofList |> ResourcePool, 30, [ Resource.Lightning ] )
      ("086", "SeelMon", "See Lion Monster", Resource.Water, [ Resource.Water, 1; ] |> Seq.ofList |> ResourcePool, 60, [ Resource.Lightning ] )
    ]
   |> List.map (fun (x,y,z,q,q2,q3, q4) -> creatureCreatureConstructor  x y z q q2 q3 q4)
   |> selectAllOkayResults
```

with selectAllOkayResults defined in the CollectinManipulation as

```S
let predicateForOkayResults z =
                        match z with
                        | Ok _ -> true
                        | _ -> false

let selectorForOkayResults z =
                        match z with
                        | Ok x ->  [ x ]
                        | _ -> []

let selectAllOkayResults (z : List<Result<'a,'b>>) =
    z
    |> List.filter predicateForOkayResults
    |> List.map selectorForOkayResults
    |> List.fold (@) []

let shuffleG xs = xs |> Seq.sortBy (fun _ -> System.Guid.NewGuid())
```

I now need to utilize these functions when setting up teh game. I want to add a mixture of resource cards and creature cards. For now I can alternate decks between creature and resource cards.

First I renamed `testCardGenerator` to `testCeatureCardGenerator` and change the function to pull information  from the sample database:

```
let testCreatureCardGenerator cardInstanceIdStr =
    let cardInstanceId = NonEmptyString.build cardInstanceIdStr |> Result.map CardInstanceId

    match cardInstanceId with
    | Ok id ->
        let card = SampleCardDatabase.creatureCardDb |> CollectionManipulation.shuffleG |> Seq.head
        Ok  {
                CardInstanceId  =  id
                Card =  card |> CharacterCard
            }
    | _ ->
        sprintf "Unable to create card instance for %s" cardInstanceIdStr
        |> Error
```

I can then create a similar function `testResourceCardGenerator`:

```
let testResourceCardGenerator cardInstanceIdStr =
    let cardInstanceId = NonEmptyString.build cardInstanceIdStr |> Result.map CardInstanceId

    match cardInstanceId with
    | Ok id ->
        let card = SampleCardDatabase.resourceCardDb |> CollectionManipulation.shuffleG |> Seq.head
        Ok  {
                CardInstanceId  =  id
                Card =  card |> ResourceCard
            }
    | _ ->
        sprintf "Unable to create card instance for %s" cardInstanceIdStr
        |> Error
```

I can then combine these two functions into `testDeckSeqGenerator`:

```
let testDeckSeqGenerator (numberOfCards :int) =
    seq { 0 .. (numberOfCards - 1)}
    |> Seq.map (fun x ->
                    if x % 2 = 1 then
                        testCreatureCardGenerator (sprintf "cardInstance-%i" x)
                    else
                        testResourceCardGenerator (sprintf "cardInstance-%i" x)
                    )
    |> List.ofSeq
    |> CollectionManipulation.selectAllOkayResults
```

I can then rewrite the init to reference the new Dbs like:

```
let init =
    let player1 = createPlayer "Player1" "Player1" 10 "https://picsum.photos/id/1000/2500/1667?blur=5"
    let player2 = createPlayer "Player2" "Player2" 10 "https://picsum.photos/id/10/2500/1667?blur=5"
    let gameId =  NonEmptyString.build "GameIDHere" |> Result.map GameId

    match player1, player2, gameId with
    | Ok p1, Ok p2, Ok g ->
        let playerBoard1 = playerBoard p1
        let playerBoard2 = playerBoard p2
        match playerBoard1, playerBoard2 with
        | Ok pb1, Ok pb2 ->
          let model : GameState =
            {
                GameId = g
                Players =  Map.empty
                Boards =   Map.empty
                NotificationMessages = None
                CurrentStep =  NotCurrentlyPlaying
                TurnNumber = 0
                PlayerOne = p1.PlayerId
                PlayerTwo = p2.PlayerId
            }

          let startGameEvent =
            {
                GameId = g
                Players =  [
                            p1.PlayerId, p1;
                            p2.PlayerId, p2
                           ] |> Map.ofList
                PlayerOne = p1.PlayerId
                PlayerTwo = p2.PlayerId
                Decks = [   (p1.PlayerId, { TopCardsExposed = 0; Cards = testDeckSeqGenerator 60 });
                            (p2.PlayerId, { TopCardsExposed = 0; Cards = testDeckSeqGenerator 60 })]
                         |> Map.ofSeq
            } |> StartGame
          let cmd = Cmd.ofMsg startGameEvent
          Ok (model, cmd)
        | _ -> "Failed to create player boards" |> Error
    | _ -> "Failed to create players" |> Error
```

I am able to see that the application does in fact now compile and renders the correct more realistic hands.

I am now able to try to wire up some functionality.

The first action I will try to implement is the "discard card" functionality on the discard button.

To do this I will need to wire up the OnClick functionality on the button.

I will wire it up by having this OnClick be a lambda sending a discard Msg like:

```
let renderCardInstanceForHand  (dispatch : Msg -> unit)  gameId playerId (card: CardInstance) =
    div [ Class "column is-4" ]
          [ div [ Class "card" ]
             [   yield! (renderCardForHand card.Card)
                 yield   footer [ Class "card-footer" ]
                      [ a [ Href "#"
                            Class "card-footer-item" ]
                          [ str "Play" ]
                        a [ Href "#"
                            OnClick (fun _->
                                            ({
                                                GameId = gameId
                                                PlayerId = playerId
                                                CardInstanceId = card.CardInstanceId
                                            } : DiscardCardEvent) |> DiscardCard |>  dispatch)
                            Class "card-footer-item" ]
                          [ str "Discard" ] ] ] ]

```

To modify the renderCardInstance like this I had to alter the function to render the card frame and card footer as opposed to the renderCardForHand.

I did this by changing the renderCardForHand like:

```
let renderCharacterCard (card: CharacterCard) =
     [
             header [ Class "card-header" ]
                        [ p [ Class "card-header-title" ]
                            [ str card.Name ]
                          p [ Class "card-header-icon" ]
                            [ str (textDescriptionForResourcePool card.ResourceCost) ] ]
             div [ Class "card-image" ]
                        [ figure [ Class "image is-4by3" ]
                            [ img [ Src (card.ImageUrl.ToString())
                                    Alt card.Name
                                    Class "is-fullwidth" ] ] ]
             div [ Class "card-content" ]
                        [ div [ Class "content" ]
                            [ p [ Class "is-italic" ]
                                [ str card.Description ]
                              displayCardSpecialEffectDetailIfPresent "On Enter Playing Field" card.EnterSpecialEffects
                              displayCardSpecialEffectDetailIfPresent "On Exit Playing Field" card.ExitSpecialEffects
                              h5 [ Class "IsTitle is5" ]
                                [ str "Attacks" ]
                              table [ ]
                                [
                                  yield! seq {
                                    for a in card.Creature.Attack do
                                      (renderAttackRow a)
                                  }
                                ] ] ]
                                ]

let renderCardForHand (card: Card) : ReactElement list=
    match card with
    | CharacterCard c -> renderCharacterCard c
    | _ ->
         [
            strong [] [ str "IDK" ]
         ]
```

I am not able to click the discard button but it doesn't function as expected! It is discarding all the cards other than the desired card!

I now have to fix the behavior of the `discardCardFromBoard` function. I have found that the bug lies in the filter on the Hand being ` (List.filter (fun x -> x.CardInstanceId = cardInstanceId) playerBoard.Hand.Cards)` and not ` (List.filter (fun x -> x.CardInstanceId <> cardInstanceId) playerBoard.Hand.Cards)`. Scanning through the code I will also have to update the similar funcationality in `addCreatureToGameState` and `playCardFromBoard`. (the fact that I had to update this logic is a real sign I need to refactor but I am ignoring this for now).

I reload the webpage and discard appears to be correctly functioning.

Now I can similarly implement the play card functionality by altering the

Refreshing the browser, nothing happens when I click play.

The first thing I did was add a notification area to the page to see if there was an error message like:

```
let notificationArea (messages :Option<Notification list>) =
    match messages with
    | Some s ->
        div []
            [
               yield!  Seq.map (fun x -> div [Class "notification is-danger"] [ str (x.ToString()) ]) s
            ]
    | _ ->
        div [] []

let mainLayout  model dispatch =
  match extractNeededModelsFromState model with
  | Ok op, Ok opb, Ok cp, Ok cpb ->
      div [ Class "container is-fluid" ]
        [ topNavigation
          br [ ]
          br [ ]
          enemyStats op opb
          enemyCreatures op opb
          playerControlCenter cp cpb model
          notificationArea model.NotificationMessages
          playerCreatures cp cpb
          playerHand model.GameId cp.PlayerId cpb.Hand dispatch
          footerBand
        ]
  | _ -> strong [] [ str "Error in GameState encountered." ]
```

After poking around for a while I realized this was never wired up at all. In the update function, I updated the
```
    | PlayCard ev ->
        model, Cmd.none
```
to
```
    | PlayCard ev ->
        modifyGameStateFromPlayCardEvent ev model, Cmd.none
```

Now it appears to be adding the creatures to the playfield. One thing that needs to be added to the UI is the total and available resources.

To do this I modified the `playerStats` function on the PageLayoutElements to include the resources like:

```
let playerStats  (player: Player) (playerBoard: PlayerBoard) =
    [             div [ Class "navbar-item" ]
                    [ a [ Class "button is-primary"
                          Href "#" ]
                        [ str (sprintf "💓 %i/10" player.RemainingLifePoints) ] ]
                  div [ Class "navbar-item" ]
                    [ a [ Class "button is-primary"
                          Href "#" ]
                        [ str (sprintf "🤚 %i" playerBoard.Hand.Cards.Length) ] ]
                  div [ Class "navbar-item" ]
                    [ a [ Class "button is-primary"
                          Href "#" ]
                        [ str (sprintf "🂠 %i" playerBoard.Deck.Cards.Length) ] ]
                  div [ Class "navbar-item" ]
                    [ a [ Class "button is-primary"
                          Href "#" ]
                        [ str (sprintf "🗑️ %i" playerBoard.DiscardPile.Cards.Length)] ]
                  div [ Class "navbar-item" ]
                    [ a [ Class "button is-primary"
                          Href "#" ]
                        [ str (sprintf "Total Res: %s" (textDescriptionForResourcePool playerBoard.TotalResourcePool))] ]
                  div [ Class "navbar-item" ]
                    [ a [ Class "button is-primary"
                          Href "#" ]
                        [ str (sprintf "Avail Res: %s" (textDescriptionForResourcePool playerBoard.AvailableResourcePool))] ] ]
```

I can now see the resources and see that the total resources are modifying but not available so I will need to update the `playCardFromBoard` function on index like:

```
let playCardFromBoard (cardInstanceId : CardInstanceId) (playerId : PlayerId) (gs: GameState) (playerBoard : PlayerBoard) =
    let cardToDiscard : CardInstance list = List.filter (fun x -> x.CardInstanceId = cardInstanceId) playerBoard.Hand.Cards

    match cardToDiscard with
    | [] ->
        (sprintf "Unable to locate card in hand with card instance id %s" (cardInstanceId.ToString())) |> Error
    | [ x ] ->
            match x.Card with
            | CharacterCard cc ->

              System.Guid.NewGuid().ToString()
              |> buildInPlayCreatureId
              |> (Result.bind (createInPlayCreatureFromCardInstance x.Card))
              |> (Result.bind (addCreatureToGameState cardInstanceId x playerId gs playerBoard))
              |> (Result.bind  (applyEffectIfDefinied cc.EnterSpecialEffects))

            | ResourceCard rc ->
              let newPb = {
                  playerBoard
                    with Hand =
                          { playerBoard.Hand with

                                Cards = (List.filter (fun x -> x.CardInstanceId <> cardInstanceId) playerBoard.Hand.Cards)
                          };
                         TotalResourcePool = addResourcesToPool playerBoard.TotalResourcePool (Map.toList rc.ResourcesAdded)
                         AvailableResourcePool =
                            if rc.ResourceAvailableOnFirstTurn then
                                addResourcesToPool playerBoard.AvailableResourcePool (Map.toList rc.ResourcesAdded)
                            else playerBoard.AvailableResourcePool
                         DiscardPile ={playerBoard.DiscardPile with Cards = playerBoard.DiscardPile.Cards @ [ x ] }
                }
              { gs with Boards = (gs.Boards.Add (playerId, newPb)) } |> (applyEffectIfDefinied rc.EnterSpecialEffects) |> Result.bind (applyEffectIfDefinied rc.ExitSpecialEffects)
            | EffectCard ec ->
              let newPb =  {
                  playerBoard
                    with Hand =
                          { playerBoard.Hand with

                                Cards = (List.filter (fun x -> x.CardInstanceId <> cardInstanceId) playerBoard.Hand.Cards)
                          };
                         DiscardPile = {playerBoard.DiscardPile with Cards = playerBoard.DiscardPile.Cards @ [ x ] }
                }
              { gs with Boards = (gs.Boards.Add (playerId, newPb) ) } |> (applyEffectIfDefinied ec.EnterSpecialEffects) |> Result.bind (applyEffectIfDefinied ec.ExitSpecialEffects)
    | _ ->
        (sprintf "ERROR: located multiple cards in hand with card instance id %s. This shouldn't happen" (cardInstanceId.ToString())) |> Error
```

With both the total and available populating the layout completely breaks so I put these two values on top of each other. This looks bad but is functional for the moment:

```
...
                  div [ Class "navbar-item" ]
                    [ a [ Class "button is-primary"
                          Href "#" ]
                        [ str (sprintf "Tot %s" (textDescriptionForResourcePool playerBoard.TotalResourcePool))
                          br []
                          str (sprintf "Ava %s" (textDescriptionForResourcePool playerBoard.AvailableResourcePool))] ] ]
...
```
I now notice that I am able to play cards for which I don't have the resources, as well as my available resources, are not being decremented.

To implement this I had to create a number of functions and rewrite the play logic to take this into account like:

```

let getNeededResourcesForCard card =
    match card with
    | CharacterCard cc -> cc.ResourceCost
    | ResourceCard rc -> rc.ResourceCost
    | EffectCard ec -> ec.ResourceCost

let tryRemoveResourceFromPlayerBoard (playerBoard:PlayerBoard) x y =
    match playerBoard.AvailableResourcePool.TryGetValue(x) with
    | true, z when z >= y -> Ok {playerBoard with AvailableResourcePool = (addResourcesToPool playerBoard.AvailableResourcePool  [ (x,  y) ])  }
    | _, _ -> sprintf "Not enough %s" (getSymbolForResource x) |> Error

let rec decrementResourcesFromPlayerBoard playerBoard resourcePool =
    match resourcePool with
    | [] -> Ok playerBoard
    | [ (x, y) ] -> tryRemoveResourceFromPlayerBoard playerBoard x y
    | (x, y) :: xs ->
        match tryRemoveResourceFromPlayerBoard playerBoard x y with
        | Error e -> e |> Error
        | Ok pb -> decrementResourcesFromPlayerBoard pb xs


let decrementRequiredResourcesFromModel cardToDiscard (playerId : PlayerId) (gs: GameState) (playerBoard : PlayerBoard) =
     getNeededResourcesForCard cardToDiscard
     |> Map.toList
     |> decrementResourcesFromPlayerBoard playerBoard
     |> Result.bind (fun updatedPlayerBoard -> Ok {gs with Boards = gs.Boards.Add(playerId, updatedPlayerBoard) })


let playCardFromBoardImp cardInstanceId playerId playerBoard (x : CardInstance) cardToDiscard gs =
    match x.Card with
               | CharacterCard cc ->

                 System.Guid.NewGuid().ToString()
                 |> buildInPlayCreatureId
                 |> (Result.bind (createInPlayCreatureFromCardInstance x.Card))
                 |> (Result.bind (addCreatureToGameState cardInstanceId x playerId gs playerBoard))
                 |> (Result.bind  (applyEffectIfDefinied cc.EnterSpecialEffects))

               | ResourceCard rc ->
                 let newAvailResourcePool =
                               if rc.ResourceAvailableOnFirstTurn then
                                   addResourcesToPool playerBoard.AvailableResourcePool (Map.toList rc.ResourcesAdded)
                               else
                                   playerBoard.AvailableResourcePool
                 let newPb = {
                     playerBoard
                       with Hand =
                             {
                               playerBoard.Hand with
                                   Cards = (List.filter (fun x -> x.CardInstanceId <> cardInstanceId) playerBoard.Hand.Cards)
                             }
                            TotalResourcePool = addResourcesToPool playerBoard.TotalResourcePool (Map.toList rc.ResourcesAdded)
                            AvailableResourcePool = newAvailResourcePool
                            DiscardPile ={playerBoard.DiscardPile with Cards = playerBoard.DiscardPile.Cards @ [ x ] }
                   }
                 { gs with Boards = (gs.Boards.Add (playerId, newPb)) } |> (applyEffectIfDefinied rc.EnterSpecialEffects) |> Result.bind (applyEffectIfDefinied rc.ExitSpecialEffects)
               | EffectCard ec ->
                 let newPb =  {
                     playerBoard
                       with Hand =
                             { playerBoard.Hand with

                                   Cards = (List.filter (fun x -> x.CardInstanceId <> cardInstanceId) playerBoard.Hand.Cards)
                             };
                            DiscardPile = {playerBoard.DiscardPile with Cards = playerBoard.DiscardPile.Cards @ [ x ] }
                   }
                 { gs with Boards = (gs.Boards.Add (playerId, newPb) ) } |> (applyEffectIfDefinied ec.EnterSpecialEffects) |> Result.bind (applyEffectIfDefinied ec.ExitSpecialEffects)


let playCardFromBoard (cardInstanceId : CardInstanceId) (playerId : PlayerId) (gs: GameState) (playerBoard : PlayerBoard) =
    let cardToDiscard : CardInstance list = List.filter (fun x -> x.CardInstanceId = cardInstanceId) playerBoard.Hand.Cards

    match cardToDiscard with
    | [] ->
        (sprintf "Unable to locate card in hand with card instance id %s" (cardInstanceId.ToString())) |> Error
    | [ x ] ->
        decrementRequiredResourcesFromModel x.Card playerId gs playerBoard
        |> Result.bind (playCardFromBoardImp cardInstanceId playerId playerBoard x cardToDiscard)
    | _ ->
        (sprintf "ERROR: located multiple cards in hand with card instance id %s. This shouldn't happen" (cardInstanceId.ToString())) |> Error
```

From a testing standpoint, the lack of rendering the resource cards has become quite difficult to deal with so I have added a simple rendering for the resource cards:

```

let renderResourceCard (card: ResourceCard) =
    [
            header [ Class "card-header" ]
                       [ p [ Class "card-header-title" ]
                           [ str card.Name ]
                         p [ Class "card-header-icon" ]
                           [ str (textDescriptionForResourcePool card.ResourceCost) ] ]
            div [ Class "card-image" ]
                       [ figure [ Class "image is-4by3" ]
                           [ img [ Src (card.ImageUrl.ToString())
                                   Alt card.Name
                                   Class "is-fullwidth" ] ] ]
            div [ Class "card-content" ]
                       [ div [ Class "content" ]
                           [ p [ Class "is-italic" ]
                               [ str card.Description ]
                             displayCardSpecialEffectDetailIfPresent "On Enter Playing Field" card.EnterSpecialEffects
                             displayCardSpecialEffectDetailIfPresent "On Exit Playing Field" card.ExitSpecialEffects
                           ] ] ]


let renderCardForHand (card: Card) : ReactElement list=
    match card with
    | CharacterCard c -> renderCharacterCard c
    | ResourceCard rc -> renderResourceCard rc
    | _ ->
         [
            strong [] [ str "IDK" ]
         ]
```


One thing I have realized is that I need to add functionality to remove old notifications. To do this I will need to add an id to the `Notification`s, define a Msg `DeleteNotification` which removes the notification with a specified id. Then I will add a delete button the to UI which sends a `DeleteNotification` message.

The UI update will be:
```
let notificationArea (messages :Option<Notification list>) dispatch=
    match messages with
    | Some s ->
        div []
            [
               yield!  Seq.map (fun x -> div [Class "notification is-danger"] [
                                                    button [ Class "delete"
                                                             OnClick (fun y -> x.Id |> DeleteNotification |> dispatch)
                                                            ] []
                                                    str x.Content ]) s
            ]
    | _ ->
        div [] []
```

The domain update to the notification will be:
```
    ...
    and Notification =
        {
            Id: Guid
            Content: string
        }
    ...

    let createNotification message ={Id = Guid.NewGuid(); Content = message}
```

The Msg type I also updated to remove the outdated GameStarted type:

```
type Msg =
    | StartGame of StartGameEvent
    | DrawCard of DrawCardEvent
    | DiscardCard of DiscardCardEvent
    | PlayCard of PlayCardEvent
    | EndPlayStep of EndPlayStepEvent
    | PerformAttack of PerformAttackEvent
    | SkipAttack of SkipAttackEvent
    | EndTurn of EndTurnEvent
    | DeleteNotification of Guid
    | GameWon of GameWonEvent
```

I can then update `update` to include the new event
```
    | DeleteNotification dn ->
        removeNotification model dn, Cmd.none
```

and define `removeNotification` as

```
let filterNotificationList notificationId l =
    l |> List.filter (fun x -> x.Id <> notificationId)
    |> function
        | [] -> None
        | x -> Some x

let removeNotification gs notificationId =
   { gs with NotificationMessages = match gs.NotificationMessages with
                                    | Some x -> filterNotificationList notificationId x
                                    | None -> None
   }
```

This all appears to build so I am leave this as the final change in the branch `step-9-better-sample-data-and-wiring-up-ui`.

[Git branch for this step](https://github.com/jamesclancy/SafeCardGame/tree/step-9-better-sample-data-and-wiring-up-ui)